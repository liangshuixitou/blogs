{"meta":{"title":"l1hy�ĸ��˲���","subtitle":"","description":"","author":"l1hy","url":"http://www.l1hy.top","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2021-02-20T00:32:01.423Z","updated":"2021-02-19T02:11:10.636Z","comments":false,"path":"/404.html","permalink":"http://www.l1hy.top/404.html","excerpt":"","text":""},{"title":"友情链接","date":"2021-02-19T02:11:10.638Z","updated":"2021-02-19T02:11:10.638Z","comments":true,"path":"links/index.html","permalink":"http://www.l1hy.top/links/index.html","excerpt":"","text":""},{"title":"分类","date":"2021-02-19T02:11:10.638Z","updated":"2021-02-19T02:11:10.638Z","comments":false,"path":"categories/index.html","permalink":"http://www.l1hy.top/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-02-19T02:11:10.639Z","updated":"2021-02-19T02:11:10.639Z","comments":false,"path":"tags/index.html","permalink":"http://www.l1hy.top/tags/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2021-02-19T02:11:10.638Z","updated":"2021-02-19T02:11:10.638Z","comments":false,"path":"repository/index.html","permalink":"http://www.l1hy.top/repository/index.html","excerpt":"","text":""},{"title":"关于","date":"2021-02-19T13:49:47.242Z","updated":"2021-02-19T13:49:47.242Z","comments":false,"path":"about/index.html","permalink":"http://www.l1hy.top/about/index.html","excerpt":"","text":"南京航空航天大学"}],"posts":[{"title":"剑指Offer-机器人的运动范围","slug":"剑指Offer-机器人的运动范围","date":"2021-02-26T03:17:58.000Z","updated":"2021-02-26T03:34:17.611Z","comments":true,"path":"2021/02/26/剑指Offer-机器人的运动范围/","link":"","permalink":"http://www.l1hy.top/2021/02/26/%E5%89%91%E6%8C%87Offer-%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/","excerpt":"","text":"机器人的运动范围 题目描述 地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？ 示例 1： 输入：m = 2, n = 3, k = 1 输出：3 示例 2： 输入：m = 3, n = 1, k = 0 输出：1 题解 BFS 利用广度有限搜索进行渲染即可，注意我们在搜索的过程中搜索方向可以缩减为向右和向下，而不必再向上和向左进行搜索。 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123; public int movingCount(int m, int n, int k) &#123; boolean[][] visit = new boolean[m][n]; Queue&lt;int []&gt; queue = new LinkedList&lt;int []&gt;(); int[] dx = new int[] &#123;1, 0&#125;; int[] dy = new int[] &#123;0, 1&#125;; queue.offer(new int[] &#123;0, 0&#125;); visit[0][0] = true; int ans = 1; while(!queue.isEmpty()) &#123; int[] cur = queue.poll(); for (int i = 0; i &lt; 2; ++i) &#123; int x = dx[i] + cur[0]; int y = dy[i] + cur[1]; if (x &lt; 0 || x &gt;= m || y &lt; 0 || y &gt;= n || visit[x][y] || !isAccorded(x, y, k)) &#123; continue; &#125; queue.offer(new int[] &#123;x, y&#125;); visit[x][y] = true; ans++; &#125; &#125; return ans; &#125; public boolean isAccorded (int m, int n, int k) &#123; int ans = 0; while (m != 0) &#123; ans += m % 10; m /= 10; &#125; while (n != 0) &#123; ans += n % 10; n /= 10; &#125; return ans &lt;= k; &#125;&#125; DFS 该题也可以利用深度优先搜索来完成，返回值为各个方向上的值相加即可，注意DFS也可以进行方向优化 1234567891011121314151617181920212223242526272829303132class Solution &#123; public int movingCount(int m, int n, int k) &#123; boolean[][] visit = new boolean[m][n]; return DFS(0, 0, visit, m, n, k); &#125; public int DFS(int x, int y, boolean[][] visit, int m, int n, int k) &#123; if (x &lt; 0 || y &lt; 0 || x &gt;= m || y &gt;= n || visit[x][y] || !isAccorded(x, y, k)) &#123; return 0; &#125; visit[x][y] = true; return 1 + DFS(x + 1, y, visit, m, n, k) + DFS(x - 1, y, visit, m, n, k) + DFS(x, y - 1, visit, m, n, k) + DFS(x, y + 1, visit, m, n, k); &#125; public boolean isAccorded (int m, int n, int k) &#123; int ans = 0; while (m != 0) &#123; ans += m % 10; m /= 10; &#125; while (n != 0) &#123; ans += n % 10; n /= 10; &#125; return ans &lt;= k; &#125;&#125;","categories":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"http://www.l1hy.top/categories/%E5%89%91%E6%8C%87Offer/"}],"tags":[{"name":"广度优先搜索","slug":"广度优先搜索","permalink":"http://www.l1hy.top/tags/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"},{"name":"深度优先搜索","slug":"深度优先搜索","permalink":"http://www.l1hy.top/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"}]},{"title":"剑指Offer-矩阵中的路径","slug":"剑指Offer-矩阵中的路径","date":"2021-02-26T01:53:01.000Z","updated":"2021-02-26T03:18:06.966Z","comments":true,"path":"2021/02/26/剑指Offer-矩阵中的路径/","link":"","permalink":"http://www.l1hy.top/2021/02/26/%E5%89%91%E6%8C%87Offer-%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/","excerpt":"","text":"矩阵中的路径 题目描述 请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如，在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用加粗标出）。 [[“a”,“b”,“c”,“e”], [“s”,“f”,“c”,“s”], [“a”,“d”,“e”,“e”]] 但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。 示例 1： 12输入：board &#x3D; [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word &#x3D; &quot;ABCCED&quot;输出：true 示例 2： 12输入：board &#x3D; [[&quot;a&quot;,&quot;b&quot;],[&quot;c&quot;,&quot;d&quot;]], word &#x3D; &quot;abcd&quot;输出：false 题解 采用DFS在矩阵中进行穷举搜索，注意需要设置flag矩阵放置重复搜索，在进入递归前设置为true，出递归后复位，事实上也可以通过board矩阵本身进行判断是否搜索过 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273class Solution &#123; public boolean exist(char[][] board, String word) &#123; if (board == null) &#123; return false; &#125; int m = board.length; if (m == 0) &#123; return false; &#125; int n = board[0].length; if (n == 0) &#123; return false; &#125; if (word == null || word.length() == 0) &#123; return false; &#125; boolean[][] flag = new boolean[m][n]; for (int i = 0; i &lt; m; ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; flag[i][j] = false; &#125; &#125; for (int i = 0; i &lt; m; ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; if (board[i][j] == word.charAt(0)) &#123; flag[i][j] = true; if (DFS(i + 1, j, board, flag, word, 1, m, n)) &#123; return true; &#125; if (DFS(i - 1, j, board, flag, word, 1, m, n)) &#123; return true; &#125; if (DFS(i, j + 1, board, flag, word, 1, m, n)) &#123; return true; &#125; if (DFS(i, j - 1, board, flag, word, 1, m, n)) &#123; return true; &#125; flag[i][j] = false; &#125; &#125; &#125; return false; &#125; public boolean DFS (int i, int j, char[][] board, boolean[][] flag, String word, int k, int m, int n) &#123; if (k == word.length()) &#123; return true; &#125; if (i &lt; 0 || i &gt;= m || j &lt; 0 || j &gt;= n || flag[i][j]) &#123; return false; &#125; if (word.charAt(k) == board[i][j]) &#123; flag[i][j] = true; if (DFS(i + 1, j, board, flag, word, k + 1, m, n)) &#123; return true; &#125; if (DFS(i - 1, j, board, flag, word, k + 1, m, n)) &#123; return true; &#125; if (DFS(i, j + 1, board, flag, word, k + 1, m, n)) &#123; return true; &#125; if (DFS(i, j - 1, board, flag, word, k + 1, m, n)) &#123; return true; &#125; flag[i][j] = false; return false; &#125; else &#123; return false; &#125; &#125;&#125;","categories":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"http://www.l1hy.top/categories/%E5%89%91%E6%8C%87Offer/"}],"tags":[{"name":"深度优先搜索","slug":"深度优先搜索","permalink":"http://www.l1hy.top/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"}]},{"title":"剑指Offer-重建二叉树","slug":"剑指Offer-重建二叉树","date":"2021-02-25T12:33:39.000Z","updated":"2021-02-26T01:53:44.175Z","comments":true,"path":"2021/02/25/剑指Offer-重建二叉树/","link":"","permalink":"http://www.l1hy.top/2021/02/25/%E5%89%91%E6%8C%87Offer-%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/","excerpt":"","text":"重建二叉树 题目描述 输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。 例如，给出 前序遍历 preorder = [3,9,20,15,7] 中序遍历 inorder = [9,3,15,20,7] 返回如下的二叉树： 12345 3 &#x2F; \\9 20 &#x2F; \\ 15 7 题解 在先序遍历的开头必定试root节点，然后在中序遍历中查找到相同的节点，即可对两个数组做一个划分，然后递归实现，递归出口是长度为0的数组返回null 对于任意一颗树而言，前序遍历的形式总是 [ 根节点, [左子树的前序遍历结果], [右子树的前序遍历结果] ] 即根节点总是前序遍历中的第一个节点。而中序遍历的形式总是 [ [左子树的中序遍历结果], 根节点, [右子树的中序遍历结果] ] 12345678910111213141516171819202122232425262728** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public TreeNode buildTree(int[] preorder, int[] inorder) &#123; int len = preorder.length; return build(0, len, preorder, 0, len, inorder); &#125; public TreeNode build(int low1, int high1, int[] preorder, int low2, int high2, int[] inorder) &#123; int len = high1 - low1; if (len == 0) &#123; return null; &#125; TreeNode root = new TreeNode(preorder[low1]); int index = 0; for (; inorder[index + low2] != preorder[low1]; ++index); root.left = build(low1 + 1, index + low1 + 1, preorder, low2, low2 + index, inorder); root.right = build(low1 + index + 1, low1 + len, preorder, low2 + index + 1, low2 + len, inorder); return root; &#125;&#125;","categories":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"http://www.l1hy.top/categories/%E5%89%91%E6%8C%87Offer/"}],"tags":[{"name":"medium","slug":"medium","permalink":"http://www.l1hy.top/tags/medium/"},{"name":"递归","slug":"递归","permalink":"http://www.l1hy.top/tags/%E9%80%92%E5%BD%92/"},{"name":"树","slug":"树","permalink":"http://www.l1hy.top/tags/%E6%A0%91/"}]},{"title":"剑指Offer-二维数组中的查找","slug":"剑指Offer-二维数组中的查找","date":"2021-02-25T05:17:49.000Z","updated":"2021-02-25T12:34:44.917Z","comments":true,"path":"2021/02/25/剑指Offer-二维数组中的查找/","link":"","permalink":"http://www.l1hy.top/2021/02/25/%E5%89%91%E6%8C%87Offer-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/","excerpt":"","text":"二维数组中的查找 题目描述 在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 示例: 现有矩阵 matrix 如下： [ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30] ] 给定 target = 5，返回 true。 给定 target = 20，返回 false。 题解 从矩阵的右上角或者左下角开始搜索即可，以右上角为例，若是大于target，则向下移动，若是小于则向左移动即可。 12345678910111213141516171819202122232425class Solution &#123; public boolean findNumberIn2DArray(int[][] matrix, int target) &#123; int m = matrix.length; if (m == 0) &#123; return false; &#125; int n = matrix[0].length; if (n == 0) &#123; return false; &#125; int i = 0; int j = n - 1; while (i &lt; m &amp;&amp; j &gt;= 0) &#123; if (matrix[i][j] &gt; target) &#123; j--; &#125; else if (matrix[i][j] &lt; target) &#123; i++; &#125; else &#123; return true; &#125; &#125; return false; &#125;&#125;","categories":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"http://www.l1hy.top/categories/%E5%89%91%E6%8C%87Offer/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://www.l1hy.top/tags/%E6%95%B0%E7%BB%84/"},{"name":"medium","slug":"medium","permalink":"http://www.l1hy.top/tags/medium/"},{"name":"双指针","slug":"双指针","permalink":"http://www.l1hy.top/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"}]},{"title":"剑指Offer-数组中重复的数字","slug":"剑指Offer-数组中重复的数字","date":"2021-02-24T15:21:14.000Z","updated":"2021-02-24T15:23:49.042Z","comments":true,"path":"2021/02/24/剑指Offer-数组中重复的数字/","link":"","permalink":"http://www.l1hy.top/2021/02/24/%E5%89%91%E6%8C%87Offer-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/","excerpt":"","text":"数组中重复的数字 题目描述 找出数组中重复的数字。 在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。 示例 1： 输入： [2, 3, 1, 0, 2, 5, 3] 输出：2 或 3 题解 利用java中的HashSet即可 1234567891011121314class Solution &#123; public int findRepeatNumber(int[] nums) &#123; Set hashSet = new HashSet(); int n = nums.length; for (int i = 0; i &lt; n; ++i) &#123; if (!hashSet.contains(nums[i])) &#123; hashSet.add(nums[i]); &#125; else &#123; return nums[i]; &#125; &#125; return nums[0]; &#125;&#125;","categories":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"http://www.l1hy.top/categories/%E5%89%91%E6%8C%87Offer/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://www.l1hy.top/tags/%E6%95%B0%E7%BB%84/"},{"name":"哈希表","slug":"哈希表","permalink":"http://www.l1hy.top/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"name":"easy","slug":"easy","permalink":"http://www.l1hy.top/tags/easy/"}]},{"title":"832-翻转图像","slug":"832-翻转图像","date":"2021-02-24T15:03:06.000Z","updated":"2021-02-24T15:21:27.593Z","comments":true,"path":"2021/02/24/832-翻转图像/","link":"","permalink":"http://www.l1hy.top/2021/02/24/832-%E7%BF%BB%E8%BD%AC%E5%9B%BE%E5%83%8F/","excerpt":"","text":"[832]翻转图像 题目描述 给定一个二进制矩阵 A，我们想先水平翻转图像，然后反转图像并返回结果。 水平翻转图片就是将图片的每一行都进行翻转，即逆序。例如，水平翻转 [1, 1, 0] 的结果是 [0, 1, 1]。 反转图片的意思是图片中的 0 全部被 1 替换， 1 全部被 0 替换。例如，反转 [0, 1, 1] 的结果是 [1, 0, 0]。 示例 1： 输入：[[1,1,0],[1,0,1],[0,0,0]] 输出：[[1,0,0],[0,1,0],[1,1,1]] 解释：首先翻转每一行: [[0,1,1],[1,0,1],[0,0,0]]； 然后反转图片: [[1,0,0],[0,1,0],[1,1,1]] 示例 2： 输入：[[1,1,0,0],[1,0,0,1],[0,1,1,1],[1,0,1,0]] 输出：[[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]] 解释：首先翻转每一行: [[0,0,1,1],[1,0,0,1],[1,1,1,0],[0,1,0,1]]； 然后反转图片: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]] 题解 暴力求解 根据题目描述进行对应操作即可，在原来的数组上，遍历[0, n / 2)列进行反转即可 1234567891011121314151617class Solution &#123; public int[][] flipAndInvertImage(int[][] A) &#123; int m = A.length; int n = A[0].length; for (int i = 0; i &lt; m; ++i) &#123; for (int j = 0; j &lt; n / 2; ++j) &#123; int t = A[i][j]; A[i][j] = A[i][n - 1 - j]; A[i][n - 1 - j] = t; &#125; for (int j = 0; j &lt; n; ++j) &#123; A[i][j] = 1 - A[i][j]; &#125; &#125; return A; &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.l1hy.top/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://www.l1hy.top/tags/%E6%95%B0%E7%BB%84/"},{"name":"easy","slug":"easy","permalink":"http://www.l1hy.top/tags/easy/"}]},{"title":"1052-爱生气的书店老板","slug":"1052-爱生气的书店老板","date":"2021-02-23T07:21:29.000Z","updated":"2021-02-24T15:21:43.320Z","comments":true,"path":"2021/02/23/1052-爱生气的书店老板/","link":"","permalink":"http://www.l1hy.top/2021/02/23/1052-%E7%88%B1%E7%94%9F%E6%B0%94%E7%9A%84%E4%B9%A6%E5%BA%97%E8%80%81%E6%9D%BF/","excerpt":"","text":"[1052]爱生气的书店老板 题目描述 今天，书店老板有一家店打算试营业 customers.length 分钟。每分钟都有一些顾客（customers[i]）会进入书店，所有这些顾客都会在那一分钟结束后离开。 在某些时候，书店老板会生气。 如果书店老板在第 i 分钟生气，那么 grumpy[i] = 1，否则 grumpy[i] = 0。 当书店老板生气时，那一分钟的顾客就会不满意，不生气则他们是满意的。 书店老板知道一个秘密技巧，能抑制自己的情绪，可以让自己连续 X 分钟不生气，但却只能使用一次。 请你返回这一天营业下来，最多有多少客户能够感到满意的数量。 示例： 输入：customers = [1,0,1,2,1,1,7,5], grumpy = [0,1,0,1,0,1,0,1], X = 3 输出：16 解释： 书店老板在最后 3 分钟保持冷静。 感到满意的最大客户数量 = 1 + 1 + 1 + 1 + 7 + 5 = 16. 题解 利用滑动窗口即可，将两个输入的数组进行相乘，然后利用滑动窗口计算长度为X的窗口内最大可节省的不生气的收益，再与之前的满意数量相加即可。 1234567891011121314151617181920212223242526272829class Solution &#123; public int maxSatisfied(int[] customers, int[] grumpy, int X) &#123; int n = customers.length; if (n == 0) &#123; return 0; &#125; // 总的可以达到的满意程度 int sum = 0; int[] grumpys = new int[n]; for (int i = 0; i &lt; n; ++i) &#123; grumpys[i] = customers[i] * grumpy[i]; if (grumpy[i] == 0) &#123; sum += customers[i]; &#125; &#125; int max = 0; int ans = 0; for (int i = 0; i &lt; X; ++i) &#123; ans += grumpys[i]; &#125; max = ans; for (int i = 1; i &lt; n - X + 1; ++i) &#123; ans += grumpys[i + X - 1]; ans -= grumpys[i - 1]; max = Math.max(ans, max); &#125; return max + sum; &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.l1hy.top/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://www.l1hy.top/tags/%E6%95%B0%E7%BB%84/"},{"name":"滑动窗口","slug":"滑动窗口","permalink":"http://www.l1hy.top/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"},{"name":"medium","slug":"medium","permalink":"http://www.l1hy.top/tags/medium/"}]},{"title":"766-托普利茨矩阵","slug":"766-托普利茨矩阵","date":"2021-02-22T13:41:19.000Z","updated":"2021-02-23T06:46:45.090Z","comments":true,"path":"2021/02/22/766-托普利茨矩阵/","link":"","permalink":"http://www.l1hy.top/2021/02/22/766-%E6%89%98%E6%99%AE%E5%88%A9%E8%8C%A8%E7%9F%A9%E9%98%B5/","excerpt":"","text":"[766]托普利茨矩阵 题目描述 给你一个 m x n 的矩阵 matrix 。如果这个矩阵是托普利茨矩阵，返回 true ；否则，返回 false 。 如果矩阵上每一条由左上到右下的对角线上的元素都相同，那么这个矩阵是 托普利茨矩阵 。 示例 1： 输入：matrix = [[1,2,3,4],[5,1,2,3],[9,5,1,2]] 输出：true 解释：在上述矩阵中, 其对角线为: “[9]”, “[5, 5]”, “[1, 1, 1]”, “[2, 2, 2]”, “[3, 3]”, “[4]”。 各条对角线上的所有元素均相同, 因此答案是 True 。 示例 2： 输入：matrix = [[1,2],[2,2]] 输出：false 解释：对角线 “[1, 2]” 上的元素不同。 题解 沿着长和宽两条边分别斜向遍历即可，注意边界 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123; public boolean isToeplitzMatrix(int[][] matrix) &#123; if (matrix == null) &#123; return true; &#125; int m = matrix.length; if (m == 1) &#123; return true; &#125; int n = matrix[0].length; if (n == 1) &#123; return true; &#125; for (int i = m - 1; i &gt;= 0; --i) &#123; int j = 0; int num = matrix[i + j][j]; while (j &lt; n &amp;&amp; i + j &lt; m) &#123; if (matrix[i + j][j] != num) &#123; return false; &#125; j++; &#125; &#125; for (int j = 1; j &lt; n; ++j) &#123; int i = 0; int num = matrix[i][i + j]; while (i &lt; m &amp;&amp; i + j &lt; n) &#123; if (matrix[i][i + j] != num) &#123; return false; &#125; ++i; &#125; &#125; return true; &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.l1hy.top/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://www.l1hy.top/tags/%E6%95%B0%E7%BB%84/"},{"name":"easy","slug":"easy","permalink":"http://www.l1hy.top/tags/easy/"}]},{"title":"3-无重复字符的最长子串","slug":"3-无重复字符的最长子串","date":"2021-02-22T07:43:59.000Z","updated":"2021-02-22T13:41:28.182Z","comments":true,"path":"2021/02/22/3-无重复字符的最长子串/","link":"","permalink":"http://www.l1hy.top/2021/02/22/3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/","excerpt":"","text":"[3]无重复字符的最长子串 题目描述 给定一个字符串，请你找出其中不含有重复字符的最长子串的长度。 示例 1: 输入: s = “abcabcbb” 输出: 3 解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。 示例 2: 输入: s = “bbbbb” 输出: 1 解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。 示例 3: 输入: s = “pwwkew” 输出: 3 解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，“pwke” 是一个子序列，不是子串。 示例 4: 输入: s = “” 输出: 0 题解 动态规划 自己想的一个动态规划的解法，设计一个lens数组存储以当前字符为结尾的最长无重复字符子串，每次计算的时候只需要前向搜索到前一个字符为结尾的最长子串的头即可，中途若是有与当前字符相同的则跳出循环。 123456789101112131415161718192021222324252627class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; if (s == null || s.length() == 0) &#123; return 0; &#125; int max = 1; int[] lens = new int[s.length()]; lens[0] = 1; for (int i = 1; i &lt; s.length(); ++i) &#123; int j; for (j = i - 1; j &gt; i - lens[i - 1] - 1; --j) &#123; if (s.charAt(i) == s.charAt(j)) &#123; break; &#125; &#125; if (j == i - lens[i - 1] - 1) &#123; lens[i] = lens[i - 1] + 1; &#125; else &#123; lens[i] = i - j; &#125; if (max &lt; lens[i]) &#123; max = lens[i]; &#125; &#125; return max; &#125;&#125; 滑动窗口与哈希表 利用滑动窗口来进行最长子串的搜索，利用哈希表来判断当前窗口中是否有重复的元素 123456789101112131415161718192021class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; if (s == null || s.length() == 0) &#123; return 0; &#125; int j = 0; int max = 1; Set window = new HashSet(); for (int i = 0; i &lt; s.length(); ++i) &#123; if (i != 0) &#123; window.remove(s.charAt(i - 1)); &#125; while (j &lt; s.length() &amp;&amp; !window.contains(s.charAt(j))) &#123; window.add(s.charAt(j)); ++j; &#125; max = Math.max(max, j - i); &#125; return max; &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.l1hy.top/categories/leetcode/"}],"tags":[{"name":"哈希表","slug":"哈希表","permalink":"http://www.l1hy.top/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"name":"medium","slug":"medium","permalink":"http://www.l1hy.top/tags/medium/"},{"name":"双指针","slug":"双指针","permalink":"http://www.l1hy.top/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"字符串","slug":"字符串","permalink":"http://www.l1hy.top/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"2-两数相加","slug":"2-两数相加","date":"2021-02-22T01:32:11.000Z","updated":"2021-02-22T05:38:49.915Z","comments":true,"path":"2021/02/22/2-两数相加/","link":"","permalink":"http://www.l1hy.top/2021/02/22/2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/","excerpt":"","text":"[2]两数相加 题目描述 给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。 请你将两个数相加，并以相同形式返回一个表示和的链表。 你可以假设除了数字 0 之外，这两个数都不会以 0 开头。 示例 1： 输入：l1 = [2,4,3], l2 = [5,6,4] 输出：[7,0,8] 解释：342 + 465 = 807. 示例 2： 输入：l1 = [0], l2 = [0] 输出：[0] 示例 3： 输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9] 输出：[8,9,9,9,0,0,0,1] 题解 类似于合并两条链表，设一个flag，然后遍历同时遍历两条链表，进行相加即可，关键在于最后要判断下是否有进位的情况 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode() &#123;&#125; * ListNode(int val) &#123; this.val = val; &#125; * ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; int flag = 0; // 标志位 int result = 0; ListNode p = l1; ListNode q = l2; ListNode t = null; // 重复部分 while (p != null &amp;&amp; q != null) &#123; result = p.val + q.val + flag; flag = 0; if (result &gt;= 10) &#123; flag = 1; result -= 10; &#125; p.val = result; p = p.next; q = q.next; &#125; while (p != null) &#123; p.val = p.val + flag; flag = 0; if (p.val &gt;= 10) &#123; flag = 1; p.val -= 10; &#125; p = p.next; &#125; while (q != null) &#123; q.val = q.val + flag; flag = 0; if (q.val &gt;= 10) &#123; flag = 1; q.val -= 10; &#125; q = q.next; &#125; if (flag == 1) &#123; t = new ListNode(1); &#125; p = l1; q = l2; while (p.next != null &amp;&amp; q.next != null) &#123; p = p.next; q = q.next; &#125; if (q.next != null) &#123; p.next = q.next; &#125; while (p.next != null) &#123; p = p.next; &#125; if (t != null) &#123; p.next = t; &#125; return l1; &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.l1hy.top/categories/leetcode/"}],"tags":[{"name":"medium","slug":"medium","permalink":"http://www.l1hy.top/tags/medium/"},{"name":"递归","slug":"递归","permalink":"http://www.l1hy.top/tags/%E9%80%92%E5%BD%92/"},{"name":"链表","slug":"链表","permalink":"http://www.l1hy.top/tags/%E9%93%BE%E8%A1%A8/"},{"name":"数学","slug":"数学","permalink":"http://www.l1hy.top/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"1-两数之和","slug":"1-两数之和","date":"2021-02-21T13:55:51.000Z","updated":"2021-02-22T01:50:17.494Z","comments":true,"path":"2021/02/21/1-两数之和/","link":"","permalink":"http://www.l1hy.top/2021/02/21/1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/","excerpt":"","text":"[1]两数之和 题目描述 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 的那 两个 整数，并返回它们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。 你可以按任意顺序返回答案。 示例 1： 输入：nums = [2,7,11,15], target = 9 输出：[0,1] 解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。 示例 2： 输入：nums = [3,2,4], target = 6 输出：[1,2] 示例 3： 输入：nums = [3,3], target = 6 输出：[0,1] 题解： 1-暴力法 强行两次循环遍历数组即可 123456789101112131415161718class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; if (nums == null || nums.length == 0 || nums.length == 1) &#123; return null; &#125; int[] result = new int[2]; for (int i = 0; i &lt; nums.length; ++i) &#123; result[0] = i; for (int j = 0; j &lt; nums.length; ++j) &#123; if (i != j &amp;&amp; nums[i] + nums[j] == target) &#123; result[1] = j; return result; &#125; &#125; &#125; return null; &#125;&#125; 2-哈希表 利用hashMap的O(1)查找，将时间降低到仅需遍历一次 1234567891011121314151617class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; if (nums == null || nums.length == 0 || nums.length == 1) &#123; return null; &#125; Map&lt;Integer, Integer&gt; hashMap = new HashMap&lt;Integer, Integer&gt;(); for (int i = 0; i &lt; nums.length; ++i) &#123; if (hashMap.containsKey(target - nums[i])) &#123; return new int[]&#123;hashMap.get(target - nums[i]), i&#125;; &#125; hashMap.put(nums[i], i); &#125; return null; &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.l1hy.top/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://www.l1hy.top/tags/%E6%95%B0%E7%BB%84/"},{"name":"哈希表","slug":"哈希表","permalink":"http://www.l1hy.top/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"name":"easy","slug":"easy","permalink":"http://www.l1hy.top/tags/easy/"}]},{"title":"Quick-start-Hexo","slug":"Quick-start","date":"2021-02-20T00:35:42.000Z","updated":"2021-02-20T01:39:08.731Z","comments":true,"path":"2021/02/20/Quick-start/","link":"","permalink":"http://www.l1hy.top/2021/02/20/Quick-start/","excerpt":"","text":"快速开始Hexo 以本博客为例，简单介绍下如何利用Hexo和github的项目page搭建起个人博客(静态网站) Hexo简介 Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 hexo官网 中有着详细的关于hexo的介绍（文档，API，主题，插件） 安装Hexo 安装前提（安装教程在后续推出） node.js Git 采用安装Hexo脚手架 1$ npm install -g hexo-cli 对于linux用户可用下面的命令将Hexo命令添加到环境变量中，win用户手动添加即可（貌似安装的时候自动添加了） 1echo &#x27;PATH=&quot;$PATH:./node_modules/.bin&quot;&#x27; &gt;&gt; ~/.profile 建立博客目录 创建一个blogs的文件夹（存放所有的博客项目）然后执行下命令 123$ hexo init blog$ cd blog$ npm install 上述命令在blogs文件夹中创建了一个名为blog的博客项目 新建完成后，blog的目录如下： 12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes _config.yml 网站的 配置 信息，您可以在此配置大部分的参数。 themes 主题 文件夹。Hexo 会根据主题来生成静态页面。 创建一篇博文 1$ hexo new &quot;My New Post&quot; 在 source/_post 目录下创建一篇名为 My New Post 的 Markdown 文件，文件开头处可配置分类信息，tag 信息等 启动本地服务 12$ hexo server$ hexo s 启动服务器。默认情况下，访问网址为： http://localhost:4000/。 选项 描述 -p, --port 重设端口 -s, --static 只使用静态文件 -l, --log 启动日记记录，使用覆盖记录格式 生成静态文件 12$ hexo generate$ hexo g 生成静态文件。 选项 描述 -d, --deploy 文件生成后立即部署网站 -w, --watch 监视文件变动 -b, --bail 生成过程中如果发生任何未处理的异常则抛出异常 -f, --force 强制重新生成文件 Hexo 引入了差分机制，如果 public 目录存在，那么 hexo g 只会重新生成改动的文件。 使用该参数的效果接近 hexo clean &amp;&amp; hexo generate -c, --concurrency 最大同时生成文件的数量，默认无限制 部署到远程站点 12$ hexo deploy$ hexo d 部署网站。 参数 描述 -g, --generate 部署之前预先生成静态文件 清理 1$ hexo clean 清除缓存文件 (db.json) 和已生成的静态文件 (public)。 在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。","categories":[{"name":"环境搭建","slug":"环境搭建","permalink":"http://www.l1hy.top/categories/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://www.l1hy.top/tags/Hexo/"},{"name":"Markdown","slug":"Markdown","permalink":"http://www.l1hy.top/tags/Markdown/"}]}],"categories":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"http://www.l1hy.top/categories/%E5%89%91%E6%8C%87Offer/"},{"name":"leetcode","slug":"leetcode","permalink":"http://www.l1hy.top/categories/leetcode/"},{"name":"环境搭建","slug":"环境搭建","permalink":"http://www.l1hy.top/categories/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"广度优先搜索","slug":"广度优先搜索","permalink":"http://www.l1hy.top/tags/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"},{"name":"深度优先搜索","slug":"深度优先搜索","permalink":"http://www.l1hy.top/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"},{"name":"medium","slug":"medium","permalink":"http://www.l1hy.top/tags/medium/"},{"name":"递归","slug":"递归","permalink":"http://www.l1hy.top/tags/%E9%80%92%E5%BD%92/"},{"name":"树","slug":"树","permalink":"http://www.l1hy.top/tags/%E6%A0%91/"},{"name":"数组","slug":"数组","permalink":"http://www.l1hy.top/tags/%E6%95%B0%E7%BB%84/"},{"name":"双指针","slug":"双指针","permalink":"http://www.l1hy.top/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"哈希表","slug":"哈希表","permalink":"http://www.l1hy.top/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"name":"easy","slug":"easy","permalink":"http://www.l1hy.top/tags/easy/"},{"name":"滑动窗口","slug":"滑动窗口","permalink":"http://www.l1hy.top/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"},{"name":"字符串","slug":"字符串","permalink":"http://www.l1hy.top/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"链表","slug":"链表","permalink":"http://www.l1hy.top/tags/%E9%93%BE%E8%A1%A8/"},{"name":"数学","slug":"数学","permalink":"http://www.l1hy.top/tags/%E6%95%B0%E5%AD%A6/"},{"name":"Hexo","slug":"Hexo","permalink":"http://www.l1hy.top/tags/Hexo/"},{"name":"Markdown","slug":"Markdown","permalink":"http://www.l1hy.top/tags/Markdown/"}]}