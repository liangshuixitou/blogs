{"meta":{"title":"l1hy�ĸ��˲���","subtitle":"","description":"","author":"l1hy","url":"https://liangshuixitou.github.io/blogs","root":"/blogs/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2021-02-20T00:32:01.423Z","updated":"2021-02-19T02:11:10.636Z","comments":false,"path":"/404.html","permalink":"https://liangshuixitou.github.io/blogs/404.html","excerpt":"","text":""},{"title":"分类","date":"2021-02-19T02:11:10.638Z","updated":"2021-02-19T02:11:10.638Z","comments":false,"path":"categories/index.html","permalink":"https://liangshuixitou.github.io/blogs/categories/index.html","excerpt":"","text":""},{"title":"关于","date":"2021-02-19T13:49:47.242Z","updated":"2021-02-19T13:49:47.242Z","comments":false,"path":"about/index.html","permalink":"https://liangshuixitou.github.io/blogs/about/index.html","excerpt":"","text":"南京航空航天大学"},{"title":"友情链接","date":"2021-02-19T02:11:10.638Z","updated":"2021-02-19T02:11:10.638Z","comments":true,"path":"links/index.html","permalink":"https://liangshuixitou.github.io/blogs/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2021-02-19T02:11:10.638Z","updated":"2021-02-19T02:11:10.638Z","comments":false,"path":"repository/index.html","permalink":"https://liangshuixitou.github.io/blogs/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-02-19T02:11:10.639Z","updated":"2021-02-19T02:11:10.639Z","comments":false,"path":"tags/index.html","permalink":"https://liangshuixitou.github.io/blogs/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"766-托普利茨矩阵","slug":"766-托普利茨矩阵","date":"2021-02-22T13:41:19.000Z","updated":"2021-02-23T06:46:45.090Z","comments":true,"path":"2021/02/22/766-托普利茨矩阵/","link":"","permalink":"https://liangshuixitou.github.io/blogs/2021/02/22/766-%E6%89%98%E6%99%AE%E5%88%A9%E8%8C%A8%E7%9F%A9%E9%98%B5/","excerpt":"","text":"[766]托普利茨矩阵 题目描述 给你一个 m x n 的矩阵 matrix 。如果这个矩阵是托普利茨矩阵，返回 true ；否则，返回 false 。 如果矩阵上每一条由左上到右下的对角线上的元素都相同，那么这个矩阵是 托普利茨矩阵 。 示例 1： 输入：matrix = [[1,2,3,4],[5,1,2,3],[9,5,1,2]] 输出：true 解释：在上述矩阵中, 其对角线为: “[9]”, “[5, 5]”, “[1, 1, 1]”, “[2, 2, 2]”, “[3, 3]”, “[4]”。 各条对角线上的所有元素均相同, 因此答案是 True 。 示例 2： 输入：matrix = [[1,2],[2,2]] 输出：false 解释：对角线 “[1, 2]” 上的元素不同。 题解 沿着长和宽两条边分别斜向遍历即可，注意边界 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123; public boolean isToeplitzMatrix(int[][] matrix) &#123; if (matrix == null) &#123; return true; &#125; int m = matrix.length; if (m == 1) &#123; return true; &#125; int n = matrix[0].length; if (n == 1) &#123; return true; &#125; for (int i = m - 1; i &gt;= 0; --i) &#123; int j = 0; int num = matrix[i + j][j]; while (j &lt; n &amp;&amp; i + j &lt; m) &#123; if (matrix[i + j][j] != num) &#123; return false; &#125; j++; &#125; &#125; for (int j = 1; j &lt; n; ++j) &#123; int i = 0; int num = matrix[i][i + j]; while (i &lt; m &amp;&amp; i + j &lt; n) &#123; if (matrix[i][i + j] != num) &#123; return false; &#125; ++i; &#125; &#125; return true; &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://liangshuixitou.github.io/blogs/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://liangshuixitou.github.io/blogs/tags/%E6%95%B0%E7%BB%84/"},{"name":"easy","slug":"easy","permalink":"https://liangshuixitou.github.io/blogs/tags/easy/"}]},{"title":"3-无重复字符的最长子串","slug":"3-无重复字符的最长子串","date":"2021-02-22T07:43:59.000Z","updated":"2021-02-22T08:09:49.888Z","comments":true,"path":"2021/02/22/3-无重复字符的最长子串/","link":"","permalink":"https://liangshuixitou.github.io/blogs/2021/02/22/3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/","excerpt":"","text":"[3]无重复字符的最长子串 题目描述 给定一个字符串，请你找出其中不含有重复字符的最长子串的长度。 示例 1: 输入: s = “abcabcbb” 输出: 3 解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。 示例 2: 输入: s = “bbbbb” 输出: 1 解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。 示例 3: 输入: s = “pwwkew” 输出: 3 解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，“pwke” 是一个子序列，不是子串。 示例 4: 输入: s = “” 输出: 0 题解 动态规划 自己想的一个动态规划的解法，设计一个lens数组存储以当前字符为结尾的最长无重复字符子串，每次计算的时候只需要前向搜索到前一个字符为结尾的最长子串的头即可，中途若是有与当前字符相同的则跳出循环。 123456789101112131415161718192021222324252627class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; if (s == null || s.length() == 0) &#123; return 0; &#125; int max = 1; int[] lens = new int[s.length()]; lens[0] = 1; for (int i = 1; i &lt; s.length(); ++i) &#123; int j; for (j = i - 1; j &gt; i - lens[i - 1] - 1; --j) &#123; if (s.charAt(i) == s.charAt(j)) &#123; break; &#125; &#125; if (j == i - lens[i - 1] - 1) &#123; lens[i] = lens[i - 1] + 1; &#125; else &#123; lens[i] = i - j; &#125; if (max &lt; lens[i]) &#123; max = lens[i]; &#125; &#125; return max; &#125;&#125; 滑动窗口与哈希表 利用滑动窗口来进行最长子串的搜索，利用哈希表来判断当前窗口中是否有重复的元素 123456789101112131415161718192021class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; if (s == null || s.length() == 0) &#123; return 0; &#125; int j = 0; int max = 1; Set window = new HashSet(); for (int i = 0; i &lt; s.length(); ++i) &#123; if (i != 0) &#123; window.remove(s.charAt(i - 1)); &#125; while (j &lt; s.length() &amp;&amp; !window.contains(s.charAt(j))) &#123; window.add(s.charAt(j)); ++j; &#125; max = Math.max(max, j - i); &#125; return max; &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://liangshuixitou.github.io/blogs/categories/leetcode/"}],"tags":[{"name":"哈希表","slug":"哈希表","permalink":"https://liangshuixitou.github.io/blogs/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"name":"medium","slug":"medium","permalink":"https://liangshuixitou.github.io/blogs/tags/medium/"},{"name":"双指针","slug":"双指针","permalink":"https://liangshuixitou.github.io/blogs/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"字符串","slug":"字符串","permalink":"https://liangshuixitou.github.io/blogs/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"2-两数相加","slug":"2-两数相加","date":"2021-02-22T01:32:11.000Z","updated":"2021-02-22T05:38:49.915Z","comments":true,"path":"2021/02/22/2-两数相加/","link":"","permalink":"https://liangshuixitou.github.io/blogs/2021/02/22/2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/","excerpt":"","text":"[2]两数相加 题目描述 给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。 请你将两个数相加，并以相同形式返回一个表示和的链表。 你可以假设除了数字 0 之外，这两个数都不会以 0 开头。 示例 1： 输入：l1 = [2,4,3], l2 = [5,6,4] 输出：[7,0,8] 解释：342 + 465 = 807. 示例 2： 输入：l1 = [0], l2 = [0] 输出：[0] 示例 3： 输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9] 输出：[8,9,9,9,0,0,0,1] 题解 类似于合并两条链表，设一个flag，然后遍历同时遍历两条链表，进行相加即可，关键在于最后要判断下是否有进位的情况 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode() &#123;&#125; * ListNode(int val) &#123; this.val = val; &#125; * ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; int flag = 0; // 标志位 int result = 0; ListNode p = l1; ListNode q = l2; ListNode t = null; // 重复部分 while (p != null &amp;&amp; q != null) &#123; result = p.val + q.val + flag; flag = 0; if (result &gt;= 10) &#123; flag = 1; result -= 10; &#125; p.val = result; p = p.next; q = q.next; &#125; while (p != null) &#123; p.val = p.val + flag; flag = 0; if (p.val &gt;= 10) &#123; flag = 1; p.val -= 10; &#125; p = p.next; &#125; while (q != null) &#123; q.val = q.val + flag; flag = 0; if (q.val &gt;= 10) &#123; flag = 1; q.val -= 10; &#125; q = q.next; &#125; if (flag == 1) &#123; t = new ListNode(1); &#125; p = l1; q = l2; while (p.next != null &amp;&amp; q.next != null) &#123; p = p.next; q = q.next; &#125; if (q.next != null) &#123; p.next = q.next; &#125; while (p.next != null) &#123; p = p.next; &#125; if (t != null) &#123; p.next = t; &#125; return l1; &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://liangshuixitou.github.io/blogs/categories/leetcode/"}],"tags":[{"name":"递归","slug":"递归","permalink":"https://liangshuixitou.github.io/blogs/tags/%E9%80%92%E5%BD%92/"},{"name":"链表","slug":"链表","permalink":"https://liangshuixitou.github.io/blogs/tags/%E9%93%BE%E8%A1%A8/"},{"name":"数学","slug":"数学","permalink":"https://liangshuixitou.github.io/blogs/tags/%E6%95%B0%E5%AD%A6/"},{"name":"medium","slug":"medium","permalink":"https://liangshuixitou.github.io/blogs/tags/medium/"}]},{"title":"1-两数之和","slug":"1-两数之和","date":"2021-02-21T13:55:51.000Z","updated":"2021-02-22T01:50:17.494Z","comments":true,"path":"2021/02/21/1-两数之和/","link":"","permalink":"https://liangshuixitou.github.io/blogs/2021/02/21/1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/","excerpt":"","text":"[1]两数之和 题目描述 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 的那 两个 整数，并返回它们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。 你可以按任意顺序返回答案。 示例 1： 输入：nums = [2,7,11,15], target = 9 输出：[0,1] 解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。 示例 2： 输入：nums = [3,2,4], target = 6 输出：[1,2] 示例 3： 输入：nums = [3,3], target = 6 输出：[0,1] 题解： 1-暴力法 强行两次循环遍历数组即可 123456789101112131415161718class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; if (nums == null || nums.length == 0 || nums.length == 1) &#123; return null; &#125; int[] result = new int[2]; for (int i = 0; i &lt; nums.length; ++i) &#123; result[0] = i; for (int j = 0; j &lt; nums.length; ++j) &#123; if (i != j &amp;&amp; nums[i] + nums[j] == target) &#123; result[1] = j; return result; &#125; &#125; &#125; return null; &#125;&#125; 2-哈希表 利用hashMap的O(1)查找，将时间降低到仅需遍历一次 1234567891011121314151617class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; if (nums == null || nums.length == 0 || nums.length == 1) &#123; return null; &#125; Map&lt;Integer, Integer&gt; hashMap = new HashMap&lt;Integer, Integer&gt;(); for (int i = 0; i &lt; nums.length; ++i) &#123; if (hashMap.containsKey(target - nums[i])) &#123; return new int[]&#123;hashMap.get(target - nums[i]), i&#125;; &#125; hashMap.put(nums[i], i); &#125; return null; &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://liangshuixitou.github.io/blogs/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://liangshuixitou.github.io/blogs/tags/%E6%95%B0%E7%BB%84/"},{"name":"哈希表","slug":"哈希表","permalink":"https://liangshuixitou.github.io/blogs/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"name":"easy","slug":"easy","permalink":"https://liangshuixitou.github.io/blogs/tags/easy/"}]},{"title":"Quick-start-Hexo","slug":"Quick-start","date":"2021-02-20T00:35:42.000Z","updated":"2021-02-20T01:39:08.731Z","comments":true,"path":"2021/02/20/Quick-start/","link":"","permalink":"https://liangshuixitou.github.io/blogs/2021/02/20/Quick-start/","excerpt":"","text":"快速开始Hexo 以本博客为例，简单介绍下如何利用Hexo和github的项目page搭建起个人博客(静态网站) Hexo简介 Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 hexo官网 中有着详细的关于hexo的介绍（文档，API，主题，插件） 安装Hexo 安装前提（安装教程在后续推出） node.js Git 采用安装Hexo脚手架 1$ npm install -g hexo-cli 对于linux用户可用下面的命令将Hexo命令添加到环境变量中，win用户手动添加即可（貌似安装的时候自动添加了） 1echo &#x27;PATH=&quot;$PATH:./node_modules/.bin&quot;&#x27; &gt;&gt; ~/.profile 建立博客目录 创建一个blogs的文件夹（存放所有的博客项目）然后执行下命令 123$ hexo init blog$ cd blog$ npm install 上述命令在blogs文件夹中创建了一个名为blog的博客项目 新建完成后，blog的目录如下： 12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes _config.yml 网站的 配置 信息，您可以在此配置大部分的参数。 themes 主题 文件夹。Hexo 会根据主题来生成静态页面。 创建一篇博文 1$ hexo new &quot;My New Post&quot; 在 source/_post 目录下创建一篇名为 My New Post 的 Markdown 文件，文件开头处可配置分类信息，tag 信息等 启动本地服务 12$ hexo server$ hexo s 启动服务器。默认情况下，访问网址为： http://localhost:4000/。 选项 描述 -p, --port 重设端口 -s, --static 只使用静态文件 -l, --log 启动日记记录，使用覆盖记录格式 生成静态文件 12$ hexo generate$ hexo g 生成静态文件。 选项 描述 -d, --deploy 文件生成后立即部署网站 -w, --watch 监视文件变动 -b, --bail 生成过程中如果发生任何未处理的异常则抛出异常 -f, --force 强制重新生成文件 Hexo 引入了差分机制，如果 public 目录存在，那么 hexo g 只会重新生成改动的文件。 使用该参数的效果接近 hexo clean &amp;&amp; hexo generate -c, --concurrency 最大同时生成文件的数量，默认无限制 部署到远程站点 12$ hexo deploy$ hexo d 部署网站。 参数 描述 -g, --generate 部署之前预先生成静态文件 清理 1$ hexo clean 清除缓存文件 (db.json) 和已生成的静态文件 (public)。 在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。","categories":[{"name":"环境搭建","slug":"环境搭建","permalink":"https://liangshuixitou.github.io/blogs/categories/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://liangshuixitou.github.io/blogs/tags/Hexo/"},{"name":"Markdown","slug":"Markdown","permalink":"https://liangshuixitou.github.io/blogs/tags/Markdown/"}]}],"categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://liangshuixitou.github.io/blogs/categories/leetcode/"},{"name":"环境搭建","slug":"环境搭建","permalink":"https://liangshuixitou.github.io/blogs/categories/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://liangshuixitou.github.io/blogs/tags/%E6%95%B0%E7%BB%84/"},{"name":"easy","slug":"easy","permalink":"https://liangshuixitou.github.io/blogs/tags/easy/"},{"name":"哈希表","slug":"哈希表","permalink":"https://liangshuixitou.github.io/blogs/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"name":"medium","slug":"medium","permalink":"https://liangshuixitou.github.io/blogs/tags/medium/"},{"name":"双指针","slug":"双指针","permalink":"https://liangshuixitou.github.io/blogs/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"字符串","slug":"字符串","permalink":"https://liangshuixitou.github.io/blogs/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"递归","slug":"递归","permalink":"https://liangshuixitou.github.io/blogs/tags/%E9%80%92%E5%BD%92/"},{"name":"链表","slug":"链表","permalink":"https://liangshuixitou.github.io/blogs/tags/%E9%93%BE%E8%A1%A8/"},{"name":"数学","slug":"数学","permalink":"https://liangshuixitou.github.io/blogs/tags/%E6%95%B0%E5%AD%A6/"},{"name":"Hexo","slug":"Hexo","permalink":"https://liangshuixitou.github.io/blogs/tags/Hexo/"},{"name":"Markdown","slug":"Markdown","permalink":"https://liangshuixitou.github.io/blogs/tags/Markdown/"}]}